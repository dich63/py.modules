# Autogenerated with SMOP version
# /usr/local/bin/smop ../Example_RA065_1st_barrier/solver/pade_laplace_LU.m

# from __future__ import division
# try:
#     from runtime import *
# except ImportError:
#     from smop.runtime import *

from .emtClass import Dat

import scipy.io as sio

global_affine_pade_data = None

def pade_laplace_LU_(*args,**kwargs):

    global global_affine_pade_data
    if not ((global_affine_pade_data)):

        print('initialization...')
        global_affine_pade_data = sio.loadmat('global_affine_pade_data_0.mat')["global_affine_pade_data"]

    print("load")

    pd = set_methods_()
    return pd


def set_methods_(ps = None):

    ps = Dat()

    ps.exp=exp_m_
    ps.pexp=pexp_m_
    #ps.expm=expm_m_
    ps.get_data=get_data_
    ps.get_solve_qp=get_solve_qp_
    ps.LU_cache=LU_cache_
    ps.LU_cache_cell=LU_cache_cell_
    ps.create_step=create_step_
    ps.laplace_RF=laplace_RF_
    ps.exp_CA_step=exp_CA_step_
    ps.calc_RF=calc_RF_
    ps.step_RF=step_RF_
    ps.add_2x2_flux=add_2x2_flux_
    ps.add_2x2_fluxes=add_2x2_fluxes_
    ps.add_fluxes=add_2x2_flux_
    ps.set_2x2_fluxes=set_2x2_fluxes_
    ps.set_2x2_fluxes_raw=set_2x2_fluxes_raw_
    ps.index2D=index2D_
    ps.pool_check=pool_check_
    ps.pool_check_cache=pool_check_cache_
    ps.pool_open=pool_open_
    ps.cellshell=cellshell_
    ps.pz=poleszeros_
    ps.rect_to_poly=rect_to_poly_
    ps.extendstruct=extendstruct_
    ps.opt_def=extendstruct_
    ps.hks=get_hks_
    return ps

def hks_lr_(t=None,x=None,xl=None,xr=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[t,x,xl,xr].count(None)+len(args)

    if (t < eps):
        res=double_((x >= xl) and (x <= xr))
    st=2 * sqrt_(t)
    dl=(xl - x) / st
    dr=(xr - x) / st
    res=0.5 * (erf_(dr) - erf_(dl))
    return res
def get_hks_(xd=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[xd].count(None)+len(args)

    hks=lambda x,t: hks_lr_(t,x,xd[1],xd[2])
    return hks
def rect_to_poly_(dim=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[dim].count(None)+len(args)

    x=matlabarray([dim[1],dim[2],dim[2],dim[1]])
    y=matlabarray([dim[3],dim[3],dim[4],dim[4]])
    return x,y

def index2D_(Nx=None,Ny=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[Nx,Ny].count(None)+len(args)

    if (numel_(Nx) > 1):
        Ny=Nx[2]
        Nx=Nx[1]
    s.Nx=Nx
    s.Ny=Ny
    nxy=Nx * Ny
    indexat=zeros_(Nx,Ny)
    nnmm=arange_(1,nxy)
    indexat[nnmm]=nnmm
    mindex=zeros_(nxy,2)
    for l in arange_(1,Ny).reshape(-1):
        for k in arange_(1,Nx).reshape(-1):
            mindex[indexat[k,l],:,:]=[k,l]
    s.at=indexat
    s.xy=lambda nn: mindex[nn,:]
    s.to_mesh=lambda ff: reshape_(ff,Nx,Ny)
    return s

def set_2x2_fluxes_(fluxes=None,NN=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[fluxes,NN].count(None)+len(args)

    fluxes=cellshell_(fluxes)
    fluxes=fluxes[:]
    K=numel_(fluxes)
    z=zeros_(K,1)
    fl=copy_(z)
    i1=copy_(z)
    i2=copy_(z)
    s11=copy_(z)
    s12=copy_(z)
    s21=copy_(z)
    s22=copy_(z)
    z=matlabarray([])
    for k in arange_(1,K).reshape(-1):
        f=fluxes[k]
        if isempty_(f):
            continue
        fl[k]=1
        nn=f.nn
        h2x2=f.h2x2
        i1[k]=nn[1]
        i2[k]=nn[2]
        s11[k]=h2x2[1,1]
        s12[k]=h2x2[1,2]
        s21[k]=h2x2[2,1]
        s22[k]=h2x2[2,2]
    sf=matlabarray([])
    sf.NN=NN
    sf.fl=fl
    sf.i1=i1
    sf.i2=i2
    sf.s11=s11
    sf.s12=s12
    sf.s21=s21
    sf.s22=s22
    s=set_2x2_fluxes_raw_(sf)
    return s
def set_2x2_fluxes_raw_(sf=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[sf].count(None)+len(args)

    fl=sf.fl
    i1=sf.i1(fl > 0)
    i2=sf.i2(fl > 0)
    s11=sf.s11(fl > 0)
    s21=sf.s21(fl > 0)
    s12=sf.s12(fl > 0)
    s22=sf.s22(fl > 0)
    NN=sf.NN
    s=sparse_(i1,i1,s11,NN,NN)
    s=s + sparse_(i1,i2,s12,NN,NN)
    s=s + sparse_(i2,i1,s21,NN,NN)
    s=s + sparse_(i2,i2,s22,NN,NN)
    return s
def add_2x2_flux_(H=None,h2x2=None,n1n2=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[H,h2x2,n1n2].count(None)+len(args)

    n1=n1n2[1]
    n2=n1n2[2]
    H[n1,n1]=H[n1,n1] + h2x2[1,1]
    H[n1,n2]=H[n1,n2] + h2x2[1,2]
    H[n2,n1]=H[n2,n1] + h2x2[2,1]
    H[n2,n2]=H[n2,n2] + h2x2[2,2]
    return H
def add_2x2_fluxes_(H=None,fluxes=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[H,fluxes].count(None)+len(args)

    fluxes=cellshell_(fluxes)
    fluxes=fluxes[:]
    for k in arange_(1,numel_(fluxes)).reshape(-1):
        f=fluxes[k]
        if not isempty_(f):
            nn=f.nn
            H[nn,nn]=H[nn,nn] + f.h2x2
    return H
def get_solve_qp_(a=None,b=None,n=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[a,b,n].count(None)+len(args)

    fj=lambda t: exp_(b * t).dot(t ** n)
    nf=factorial_(n)
    nn=arange_(0,(n))
    ba=a - b
    if abs_(ba) > eps:
        c=nf / factorial_(nn)
        c=fliplr_(c)
        p0=polyval_(c,0)
        ban=1 / ba ** (n + 1)
        fu=lambda t: ban * (p0 * exp_(a * t) - exp_(b * t).dot(polyval_(c,ba * t)))
    else:
        n1=n + 1
        fu=lambda t: (t ** n1).dot(exp_(a * t)) / n1
    return fu,fj
def get_data_(n=None,m=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[n,m].count(None)+len(args)

    global global_affine_pade_data
    if (numel_(n) > 1):
        m=n[2]
        n=n[1]
    n=n + 1
    m=m + 1
    r=global_affine_pade_data.data[n,m]
    rx=[r.res]
    nd=length_(r.resdP)
    rpx=zeros_(m - 1,nd)
    for nn in arange_(1,nd).reshape(-1):
        rpx[:,nn]=r.resdP[nn]
    for k in arange_(2,nd).reshape(-1):
        rx[k]=r.resdP[k - 1] / r.ndP[k - 1]
    r.resex=rx
    r.rpx=rpx
    r.Pn=r.P * r.ndiv
    r.Qn=r.Q * r.ndiv
    F=lambda t: - sum_(r.res / (t + r.poles))
    fa=lambda t: arrayfun_(F,t)
    r.lap_invert=lambda lfun,derr: get_lap_invert_(r,lfun,derr)
    r.exp_pp=fa
    r.diff_func=fa
    s.nm=r.nm
    s.p=r.poles
    s.z=roots_(flipud_(r.Pn))
    r.show=lambda : showpz_(s)
    r.showi=lambda : showpzi_(s)
    return r
def get_lap_invert_(r=None,lfun=None,derr=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[r,lfun,derr].count(None)+len(args)

    if nargin < 2:
        derr=0
    if derr:
        Functor_F=lambda t: - sum_(((r.poles / t) ** derr).dot(r.res).dot(lfun[r.poles / t])) / t
    else:
        Functor_F=lambda t: - sum_(r.res.dot(lfun[r.poles / t])) / t
    Functor=lambda t: arrayfun_(Functor_F,t)
    return Functor
def showpz_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    figure
    plot_(real_(s.z),imag_(s.z),char('o'),real_(s.p),imag_(s.p),char('+'))
    legend_(char('o zeros'),char('+ poles'))
    grid
    ss=sprintf_(char('exp->P_{%d}/Q_{%d}'),s.nm(1),s.nm(2))
    title_(ss)
    return
def showpzi_(s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[s].count(None)+len(args)

    figure
    N=200
    uc=exp_(2j * pi / N * (arange_(0,N)))
    plot_(real_(1.0 / s.z),imag_(1.0 / s.z),char('.'),real_(1.0 / s.p),imag_(1.0 / s.p),char('+'),real_(uc),imag_(uc))
    legend_(char('o zeros'),char('+ poles'))
    grid
    ss=sprintf_(char('exp(1/z)->P_{%d}/Q_{%d}'),s.nm(1),s.nm(2))
    title_(ss)
    return
def cellshell_(c=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[c].count(None)+len(args)

    if isempty_(c):
        c=[]
    else:
        if not iscell_(c):
            c=[c]
    return c
def exp_m_(pd=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pd,z].count(None)+len(args)

    r=funr_(expn,pd,z)
    return r
def pexp_m_(pd=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pd,z].count(None)+len(args)

    r=funr_(pexpn,pd,z)
    return r
def funr_(fun=None,obj=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[fun,obj,z].count(None)+len(args)

    dims=size_(z)
    z=z[:]
    nn=prod_(dims)
    r=zeros_(nn,1)
    for k in arange_(1,nn).reshape(-1):
        r[k]=fun[obj,z[k]]
    r=reshape_(r,dims)
    return r
def expn_(pd=None,z=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[pd,z].count(None)+len(args)

    zz=zigzag_(max_(pd.nm) + 1,z)
    zn=zz[1:(pd.nm(1) + 1)]
    zm=zz[1:(pd.nm(2) + 1)]
    pp=zn * pd.P
    qq=zm * pd.Q
    ez=pp / qq
    return ez
def zigzag_(m=None,p=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[m,p].count(None)+len(args)

    nn=arange_(0,m)
    zz=(p) ** (nn)
    return zz
def poleszeros_(data=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[data].count(None)+len(args)

    p=data.poles
    r=roots_(flipud_(data.P))
    return p,r
def pool_check_n_(this=None,name=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[this,name].count(None)+len(args)

    if isfield_(this,name):
        pass
    else:
        fpl=0
    if fpl and matlabpool_(char('size')) == 0:
        matlabpool_(char('open'))
    return fpl
def pool_check_(this=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[this].count(None)+len(args)

    fpl=pool_check_n_(this,char('fpool'))
    return fpl
def pool_check_cache_(this=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[this].count(None)+len(args)

    fpl=pool_check_n_(this,char('fpoolcache'))
    return fpl
def pool_check_poles_(this=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[this].count(None)+len(args)

    fpl=pool_check_n_(this,char('fpoolpoles'))
    return fpl
def LU_s_(AC=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[AC].count(None)+len(args)

    if not issparse_(AC):
        AC=sparse_(AC)
    s.L,s.U,s.p,s.q=lu_(AC,char('vector'),nargout=4)
    return s
def LU_solve_(L=None,U=None,p=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[L,U,p,x].count(None)+len(args)

    x=numpy.linalg.solve(L,x[p])
    x=numpy.linalg.solve(U,x)
    return x
def LU_solve_s_(s=None,x=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[s,x].count(None)+len(args)

    x=numpy.linalg.solve(s.L,x[s.p])
    x[s.q]=numpy.linalg.solve(s.U,x)
    return x
def LU_st_(A=None,t=None,poles=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[A,t,poles].count(None)+len(args)

    nt=numel_(t)
    st=cell_(nt,1)
    ep=matlabarray([])
    if isstruct_(A):
        C=A.C
        ep=A.eps
        A=A.A
        if isempty_(C):
            C=1
        n1,n2=size_(C,nargout=2)
        N,tt=size_(A,nargout=2)
        if (numel_(A) != numel_(C)):
            NN=arange_(1,N)
            if ((n1 == N) or (n2 == N)):
                C=sparse_(NN,NN,C)
            else:
                C=C * speye_(size_(A))
        pE=poles * C
    else:
        pE=poles * speye_(size_(A))
    fep=isempty_(ep)
    for n in arange_(1,nt).reshape(-1):
        if fep:
            st[n]=LU_s_(t[n] * A - pE)
        else:
            st[n]=LU_s_(t[n] * A - pE - (poles ** 2) * ep / t[n])
    return st
def create_step_(this=None,A=None,t=None,freal=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 4-[this,A,t,freal].count(None)+len(args)

    if exist_(char('freal')) != 1:
        freal=0
    luc=LU_cache_(this,A,t,freal)
    step=luc.exp_step
    return step,luc
def LU_cache_(this=None,A=None,t=None,freal=None,fnocycref=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[this,A,t,freal,fnocycref].count(None)+len(args)

    if exist_(char('fnocycref')) != 1:
        fnocycref=0
    if exist_(char('freal')) != 1:
        freal=0
    luc=LU_cache_cell_(this,A,t,freal,fnocycref)
    luc=luc[1]
    return luc
def pool_open_(f=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 1-[f].count(None)+len(args)

    if f:
        if matlabpool_(char('size')) == 0:
            matlabpool
    return
def LU_cache_cell_(this=None,A=None,t=None,freal=None,fnocycref=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[this,A,t,freal,fnocycref].count(None)+len(args)

    fhyp=0
    if exist_(char('fnocycref')) != 1:
        fnocycref=0
    if exist_(char('freal')) != 1:
        freal=0
    ep=matlabarray([])
    fdAC=0
    if isstruct_(A):
        N=size_(A.A,1)
        Cm=A.C
        if isfield_(A,char('dAC')):
            dAC=extendstruct_(A.dAC,struct_(char('A'),[],char('C'),[],char('dv'),1))
            dACc=cellshell_(dAC)
            for nd in arange_(1,numel_(dACc)).reshape(-1):
                dAC=dACc[nd]
                fd=0
                if not isempty_(dAC.A):
                    fd=bitor_(fd,1)
                if not isempty_(dAC.C):
                    fd=bitor_(fd,2)
                fdAC=fdAC or fd
                dACc[nd].fd=fd
            A.dAC=dACc
        if isempty_(Cm):
            Cm=1
        n1,n2=size_(Cm,nargout=2)
        N,tt=size_(A.A,nargout=2)
        if (numel_(A.A) != numel_(Cm)):
            NN=arange_(1,N)
            if ((n1 == N) or (n2 == N)):
                Cm=sparse_(NN,NN,Cm)
            else:
                Cm=Cm * speye_(size_(A.A))
        fhyp=1
        if isfield_(this,char('fhyp')):
            fhyp=this.fhyp
        if fhyp and isfield_(A,char('eps')):
            ep=A.eps
            if numel_(ep) == 1:
                A.eps=ep * speye_(N,N)
        else:
            A.eps=[]
    else:
        Cm=matlabarray([])
        ep=matlabarray([])
        N=size_(A,1)
    t=cellshell_(t)
    nt=numel_(t)
    if freal:
        poles=this.rdata.poles
        res=this.rdata.res
        m=numel_(poles)
    else:
        poles=this.poles
        res=this.res
        m=this.nm(2)
    pA=cell_(m,nt)
    fpl=pool_check_cache_(this)
    if fpl:
        for k in arange_(1,m).reshape(-1):
            pA[k,:]=LU_st_(A,t,poles[k])
    else:
        for k in arange_(1,m).reshape(-1):
            pA[k,:]=LU_st_(A,t,poles[k])
    luc=cell_(nt,1)
    fpool=pool_check_(this)
    fpool_poles=pool_check_poles_(this)
    for n in arange_(1,nt).reshape(-1):
        luc[n].N=N
        luc[n].zN=zeros_(N,1)
        luc[n].t=t[n]
        luc[n].pA=pA[:,n]
        luc[n].freal=freal
        luc[n].C=Cm
        luc[n].eps=ep
        luc[n].padedata=this
        luc[n].res=res
        luc[n].poles=poles
        luc[n].fpool=fpool
        luc[n].fpool_poles=fpool_poles
        luc[n].fhyp=fhyp
        luc[n].fnocycref=fnocycref
        luc[n].fdAC=fdAC
        luc[n].md=0
        if fdAC:
            luc[n].dAC=A.dAC
            luc[n].md=numel_(A.dAC)
        if not fnocycref:
            luc[n].exp_step=lambda X,FF: exp_step_(luc[n],X,FF)
            luc[n].exp_step2=lambda X0,FF: exp_CA_step_(luc[n],X0,FF)
            luc[n].exp_step_hyp=lambda X0,X1,FF: exp_CA_step_(luc[n],X0,FF,X1)
        luc[n].exp_step_lu=lambda lu,X,FF: exp_step_(lu,X,FF)
        luc[n].exp_step2_lu=lambda lu,X0,FF: exp_CA_step_(lu,X0,FF)
        luc[n].exp_step_hyp_lu=lambda lu,X0,X1,FF: exp_CA_step_(lu,X0,FF,X1)
        luc[n].exp_CA_step=exp_CA_step
        luc[n].exp_CA_step_vs=exp_CA_step_vs
    return luc
def step_R_(F=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[F,t].count(None)+len(args)

    if isstruct_(F):
        if isfield_(F,char('g')):
            zt=exp_(F.g * t)
        else:
            zt=1
        if isfield_(F,char('c')):
            c=F.c(arange_())
        else:
            c=1
        nc=numel_(c)
        if nc > 1:
            nnc=arange_(0,(nc - 1))
            nfact=factorial_(nnc)
            bnfact=1.0 / nfact
            Dn=diag_(nfact)
            bDn=diag_(bnfact)
            c=Dn * c
            ncf=(t ** nnc).dot(bnfact)
            for n in arange_(1,nc).reshape(-1):
                nz=zeros_([nc,1])
                nz[n:nc]=ncf[1:nc - (n - 1)]
                cn[n]=(nz.T * c)
            F.c=zt * (cn * bDn)
        else:
            F.c=zt * c
    return F
def step_RF_(FF=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[FF,t].count(None)+len(args)

    nd=numel_(FF)
    if nd == 0:
        return FF
    if iscell_(FF):
        for n in arange_(1,nd).reshape(-1):
            FF[n]=step_R_(FF[n],t)
    else:
        FF=step_R_(FF,t)
    return FF
def calc_R_(F=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[F,t].count(None)+len(args)

    if isstruct_(F):
        if isfield_(F,char('g')):
            zt=exp_(- F.g * t)
        else:
            zt=1
        if isfield_(F,char('c')):
            c=F.c(arange_()).T
        else:
            c=1
        nc=numel_(c) - 1
        zm=zt * (t ** (arange_(0,nc))) * c
        F=F.f
    else:
        zm=1
    f0=zm * F
    return f0
def calc_RF_(FF=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[FF,t].count(None)+len(args)

    nd=numel_(FF)
    if iscell_(FF):
        f0=calc_R_(FF[1],t)
        for n in arange_(2,nd).reshape(-1):
            f0=f0 + calc_R_(FF[n],t)
    else:
        f0=calc_R_(FF,t)
    return f0
def laplace_R_(F=None,s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[F,s].count(None)+len(args)

    if isstruct_(F):
        if isfield_(F,char('g')):
            z=1 / (s - F.g)
        else:
            z=1 / s
        if isfield_(F,char('c')):
            c=F.c(arange_())
        else:
            c=1
        nc=numel_(c)
        zm=((z ** (arange_(1,nc))).dot(factorial_(arange_(0,(nc - 1))))) * c
        F=F.f
    else:
        zm=1 / s
    fs=zm * F
    return fs
def laplace_RF_(FF=None,s=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[FF,s].count(None)+len(args)

    nd=numel_(FF)
    if iscell_(FF):
        fs=laplace_R_(FF[1],s)
        for n in arange_(2,nd).reshape(-1):
            fs=fs + laplace_R_(FF[n],s)
    else:
        fs=laplace_R_(FF,s)
    return fs
def laplace_RFback_(FF=None,tau=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 2-[FF,tau].count(None)+len(args)

    nd=numel_(FF)
    if nd == 1:
        f=FF[1]
        z=copy_(tau)
        if isstruct_(f):
            z=z + f.gamma
            f=f.c
        fs=f * tau
        return fs
    fs=zeros_(size_(s))
    for n in arange_(1,nd).reshape(-1):
        f=FF[n]
        z=copy_(tau)
        if isstruct_(f):
            z=z + f.gamma
            f=f.c
        fs=fs + f * factorial_(n) * tau ** (n)
    return fs
def exp_CA_poles_(s=None,polus=None,X=None,FF=None,t=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[s,polus,X,FF,t].count(None)+len(args)

    if not isempty_(FF):
        X=X + laplace_RF_(FF,polus / t)
    X=LU_solve_s_(s,X)
    return X
def exp_step_(lu_cache=None,Xc=None,FF=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[lu_cache,Xc,FF].count(None)+len(args)

    if exist_(char('FF')) != 1:
        FF=matlabarray([])
    if iscell_(Xc):
        if numel_(Xc) == 2:
            Xc[1],Xc[2]=exp_CA_step_(lu_cache,Xc[1],FF,Xc[2],nargout=2)
        else:
            Xc[1]=exp_CA_step_(lu_cache,Xc[1],FF,[])
    else:
        Xc=exp_CA_step_(lu_cache,Xc,FF,[])
    return Xc
def exp_CA_step_(lu_cache=None,X=None,FF=None,X1=None,vX0=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[lu_cache,X,FF,X1,vX0].count(None)+len(args)

    dX=matlabarray([])
    vX=matlabarray([])
    vdX=lu_cache.zN
    pd=lu_cache.padedata
    C=lu_cache.C
    if exist_(char('X1')) != 1:
        X1=matlabarray([])
    if exist_(char('FF')) != 1:
        FF=matlabarray([])
    x0=copy_(X)
    if not isempty_(C):
        X=C * x0
    fhyp=(not isempty_(lu_cache.eps))
    if fhyp and (not isempty_(X1)):
        ep=lu_cache.eps
        X=X + ep * X1
    ludata=lu_cache.pA
    poles=lu_cache.poles
    t=lu_cache.t
    res=lu_cache.res
    np=numel_(ludata)
    nnzz=cell_(np,1)
    nodes=copy_(nnzz)
    nodes1=copy_(nnzz)
    fdAC=0
    if nargout > 2:
        fdAC=lu_cache.fdAC
        if fdAC:
            nodes_v=copy_(nnzz)
            nodes1_v=copy_(nnzz)
            dAC=lu_cache.dAC[1]
    fpool=lu_cache.fpool
    fdiff=nargout > 1
    if (fpool):
        for n in arange_(1,np).reshape(-1):
            if fhyp:
                ex=res[n] * exp_CA_poles_(ludata[n],poles[n],X + (poles[n] / t) * ep * x0,FF,t)
            else:
                ex=res[n] * exp_CA_poles_(ludata[n],poles[n],X,FF,t)
            nodes[n]=ex
            if fdiff:
                nodes1[n]=(- poles[n] / t).dot(ex)
    else:
        for n in arange_(1,np).reshape(-1):
            if fhyp:
                LXn=exp_CA_poles_(ludata[n],poles[n],X + (poles[n] / t) * ep * x0,FF,t)
            else:
                LXn=exp_CA_poles_(ludata[n],poles[n],X,FF,t)
            exn=res[n] * LXn
            nodes[n]=exn
            if fdiff:
                nodes1[n]=(- poles[n] / t).dot(exn)
            if fdAC:
                v=C * vX0
                if bitand_(fdAC,1):
                    v=v + dAC.A * LXn
                if bitand_(fdAC,2):
                    v=v + dAC.C * x0
                exn=res[n] * exp_CA_poles_(ludata[n],poles[n],v,[],t)
                nodes_v[n]=exn
                nodes1_v[n]=(- poles[n] / t).dot(exn)
    kk=lu_cache.padedata.kk
    if isempty_(kk):
        X=zeros_(size_(X))
    else:
        X=kk[1] * X
    for n in arange_(1,np).reshape(-1):
        X=X + nodes[n]
    if (lu_cache.freal):
        X=real_(X)
    if nargout > 1:
        dX=zeros_(size_(X))
        for n in arange_(1,np).reshape(-1):
            dX=dX + nodes1[n]
        if (lu_cache.freal):
            dX=real_(dX)
    if fdAC:
        vX=zeros_(size_(X))
        vdX=zeros_(size_(X))
        for n in arange_(1,np).reshape(-1):
            vX=vX + nodes_v[n]
            vdX=vdX + nodes1_v[n]
        if (lu_cache.freal):
            vX=real_(vX)
            vdX=real_(vdX)
    return X,dX,vX,vdX
def reinit_sX_(sX=None,zN=None,md=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[sX,zN,md].count(None)+len(args)

    s=struct_(char('X'),zN,char('dX'),zN)
    if md > 0:
        c=cell_(1,md)
        c[:]=[zN]
        s.vX=c
        s.vdX=c
    sX=extendstruct_(sX,s)
    return sX
def exp_CA_step_vs_(lu_cache=None,sX=None,FF=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 3-[lu_cache,sX,FF].count(None)+len(args)

    if exist_(char('FF')) != 1:
        FF=matlabarray([])
    md=lu_cache.md
    zN=lu_cache.zN
    sX=reinit_sX_(sX,zN,md)
    pd=lu_cache.padedata
    X=sX.X
    C=lu_cache.C
    x0=copy_(X)
    if not isempty_(C):
        X=C * x0
    fhyp=(not isempty_(lu_cache.eps))
    if fhyp and (not isempty_(sX.dX)):
        ep=lu_cache.eps
        X=X + ep * sX.dX
    ludata=lu_cache.pA
    poles=lu_cache.poles
    t=lu_cache.t
    res=lu_cache.res
    np=numel_(ludata)
    nnzz=cell_(np,1)
    nodes=copy_(nnzz)
    nodes1=copy_(nnzz)
    fdAC=lu_cache.fdAC
    if fdAC:
        c=cell_(md,1)
        c[:]=[nnzz]
        nodes_v=copy_(c)
        nodes1_v=copy_(c)
        dAC=lu_cache.dAC
    fpool=lu_cache.fpool
    fdiff=1
    if (fpool):
        for n in arange_(1,np).reshape(-1):
            if fhyp:
                ex=res[n] * exp_CA_poles_(ludata[n],poles[n],X + (poles[n] / t) * ep * x0,FF,t)
            else:
                ex=res[n] * exp_CA_poles_(ludata[n],poles[n],X,FF,t)
            nodes[n]=ex
            if fdiff:
                nodes1[n]=(- poles[n] / t).dot(ex)
    else:
        for n in arange_(1,np).reshape(-1):
            if fhyp:
                LXn=exp_CA_poles_(ludata[n],poles[n],X + (poles[n] / t) * ep * x0,FF,t)
            else:
                LXn=exp_CA_poles_(ludata[n],poles[n],X,FF,t)
            exn=res[n] * LXn
            nodes[n]=exn
            if fdiff:
                nodes1[n]=(- poles[n] / t).dot(exn)
            if fdAC:
                for mv in arange_(1,md).reshape(-1):
                    v=C * sX.vX[mv]
                    if bitand_(fdAC,1):
                        v=v + dAC[mv].A * LXn
                    if bitand_(fdAC,2):
                        v=v + dAC[mv].C * (x0 - (poles[n] / t) * LXn)
                    exn=res[n] * exp_CA_poles_(ludata[n],poles[n],v,[],t)
                    nodes_v[mv][n]=exn
                    nodes1_v[mv][n]=(- poles[n] / t).dot(exn)
    kk=lu_cache.padedata.kk
    if isempty_(kk):
        X=zeros_(size_(X))
    else:
        X=kk[1] * X
    for n in arange_(1,np).reshape(-1):
        X=X + nodes[n]
    if (lu_cache.freal):
        X=float(X)
    sX.X=X
    dX=zeros_(size_(X))
    for n in arange_(1,np).reshape(-1):
        dX=dX + nodes1[n]
    if (lu_cache.freal):
        dX=float(dX)
    sX.dX=dX
    if fdAC:
        for mv in arange_(1,md).reshape(-1):
            vX=copy_(zN)
            vdX=copy_(zN)
            nvm=nodes_v[mv]
            nvm1=nodes1_v[mv]
            for n in arange_(1,np).reshape(-1):
                vX=vX + nvm[n]
                vdX=vdX + nvm1[n]
            if (lu_cache.freal):
                vX=float(vX)
                vdX=float(vdX)
            sX.vX[mv]=vX
            sX.vdX[mv]=vdX
    return sX

def extendstruct_(m,ma):

    #if not ma:
    #    return m
    #if not isstruct_(ma):
    #    return m
    fs=ma.__dict__.keys()
    print(fs)
    for i in range(len(fs)):
        t=fs[i]
        if not hasattr(m,t):
            setattr(m, t, getattr(ma, t))
        else:
            pass
    return m